{"cabal-version":">=1.10","name":"bytestring","version":"0.12.1.0","license":"BSD3","license-file":["LICENSE"],"license-files":["LICENSE"],"copyright":"Copyright (c) Don Stewart          2005-2009,\n(c) Duncan Coutts        2006-2015,\n(c) David Roundy         2003-2005,\n(c) Jasper Van der Jeugt 2010,\n(c) Simon Meier          2010-2013.","maintainer":"Haskell Bytestring Team <andrew.lelechenko@gmail.com>, Core Libraries Committee","author":"Don Stewart,\nDuncan Coutts","tested-with":[["ghc","==9.4.1"],["ghc","==9.2.4"],["ghc","==9.0.2"],["ghc","==8.10.7"],["ghc","==8.8.4"],["ghc","==8.6.5"],["ghc","==8.4.4"],["ghc","==8.2.2"],["ghc","==8.0.2"]],"homepage":"https://github.com/haskell/bytestring","bug-reports":"https://github.com/haskell/bytestring/issues","synopsis":"Fast, compact, strict and lazy byte strings with a list interface","description":"An efficient compact, immutable byte string type (both strict and lazy)\nsuitable for binary or 8-bit character data.\n\nThe 'ByteString' type represents sequences of bytes or 8-bit characters.\nIt is suitable for high performance use, both in terms of large data\nquantities, or high speed requirements. The 'ByteString' functions follow\nthe same style as Haskell\\'s ordinary lists, so it is easy to convert code\nfrom using 'String' to 'ByteString'.\n\nTwo 'ByteString' variants are provided:\n\n* Strict 'ByteString's keep the string as a single large array. This\nmakes them convenient for passing data between C and Haskell.\n\n* Lazy 'ByteString's use a lazy list of strict chunks which makes it\nsuitable for I\\/O streaming tasks.\n\nThe @Char8@ modules provide a character-based view of the same\nunderlying 'ByteString' types. This makes it convenient to handle mixed\nbinary and 8-bit character content (which is common in many file formats\nand network protocols).\n\nThe 'Builder' module provides an efficient way to build up 'ByteString's\nin an ad-hoc way by repeated concatenation. This is ideal for fast\nserialisation or pretty printing.\n\nThere is also a 'ShortByteString' type which has a lower memory overhead\nand can be converted to or from a 'ByteString'. It is suitable for keeping\nmany short strings in memory, especially long-term, without incurring any\npossible heap fragmentation costs.\n\n'ByteString's are not designed for Unicode. For Unicode strings you should\nuse the 'Text' type from the @text@ package.\n\nThese modules are intended to be imported qualified, to avoid name clashes\nwith \"Prelude\" functions, e.g.\n\n> import qualified Data.ByteString as BS","category":"Data","build-type":"Simple","extra-source-files":["README.md","Changelog.md","include/bytestring-cpp-macros.h"],"source-repositories":{"head":{"type":"git","location":"https://github.com/haskell/bytestring"}},"flags":{"pure-haskell":{"description":"Don't use bytestring's standard C routines\nWhen this flag is true, bytestring will use pure Haskell variants (no C FFI)\nof the internal functions. This is not recommended except in use cases that\ncannot (or do not) depend on C, such as with GHC's JavaScript backend.","default":false,"manual":true}},"components":{"lib":{"exposed-modules":["Data.ByteString","Data.ByteString.Char8","Data.ByteString.Unsafe","Data.ByteString.Internal","Data.ByteString.Lazy","Data.ByteString.Lazy.Char8","Data.ByteString.Lazy.Internal","Data.ByteString.Short","Data.ByteString.Short.Internal","Data.ByteString.Builder","Data.ByteString.Builder.Extra","Data.ByteString.Builder.Prim","Data.ByteString.Builder.RealFloat","Data.ByteString.Builder.Internal","Data.ByteString.Builder.Prim.Internal"],"other-modules":["Data.ByteString.Builder.ASCII","Data.ByteString.Builder.Prim.ASCII","Data.ByteString.Builder.Prim.Binary","Data.ByteString.Builder.Prim.Internal.Base16","Data.ByteString.Builder.Prim.Internal.Floating","Data.ByteString.Builder.RealFloat.F2S","Data.ByteString.Builder.RealFloat.D2S","Data.ByteString.Builder.RealFloat.Internal","Data.ByteString.Builder.RealFloat.TableGenerator","Data.ByteString.Internal.Type","Data.ByteString.Lazy.ReadInt","Data.ByteString.Lazy.ReadNat","Data.ByteString.ReadInt","Data.ByteString.ReadNat","Data.ByteString.Utils.ByteOrder","Data.ByteString.Utils.UnalignedAccess",{"_if":{"arch":"javascript"},"_then":["Data.ByteString.Internal.Pure"]}],"default-language":"Haskell2010","other-extensions":["CPP","ForeignFunctionInterface","BangPatterns","UnliftedFFITypes","MagicHash","UnboxedTuples","DeriveDataTypeable","ScopedTypeVariables","RankNTypes","NamedFieldPuns"],"include-dirs":["include"],"includes":["fpstring.h"],"install-includes":["fpstring.h","bytestring-cpp-macros.h"],"ghc-options":["-Wall","-fwarn-tabs","-Wincomplete-uni-patterns","-optP","-Wall","-optP","-Werror=undef","-O2","-fmax-simplifier-iterations=10","-fdicts-cheap","-fspec-constr-count=6"],"build-depends":[{"package":"base","version":">=4.9 && <5","libs":["base"]},{"package":"ghc-prim","version":">=0","libs":["ghc-prim"]},{"package":"deepseq","version":">=0","libs":["deepseq"]},{"package":"template-haskell","version":">=0","libs":["template-haskell"]},{"_if":{"impl":"ghc","range":"<9.4"},"_then":[{"package":"data-array-byte","version":">=0.1 && <0.2","libs":["data-array-byte"]}]},{"_if":{"arch":"javascript"},"_then":[{"package":"base","version":">=4.18 && <5","libs":["base"]}]}],"cpp-options":[{"_if":{"arch":"javascript"},"_then":["-DPURE_HASKELL=1"]},{"_if":{"not":{"arch":"javascript"}},"_then":["-DPURE_HASKELL=0"]}],"default-extensions":[{"_if":{"arch":"javascript"},"_then":["NoForeignFunctionInterface"]}],"cc-options":[{"_if":{"not":{"arch":"javascript"}},"_then":["-std=c11","-DNDEBUG=1","-fno-strict-aliasing","-Werror=undef"]}],"c-sources":[{"_if":{"not":{"arch":"javascript"}},"_then":["cbits/fpstring.c","cbits/itoa.c","cbits/shortbytestring.c","cbits/aligned-static-hs-data.c"]},{"_if":{"and":[{"not":{"arch":"javascript"}},{"arch":"aarch64"}]},"_then":["cbits/aarch64/is-valid-utf8.c"]},{"_if":{"and":[{"not":{"arch":"javascript"}},{"not":{"arch":"aarch64"}}]},"_then":["cbits/is-valid-utf8.c"]}],"extra-libraries":[{"_if":{"and":[{"not":{"arch":"javascript"}},{"and":[{"os":"windows"},{"impl":"ghc","range":"<9.3"}]}]},"_then":["gcc"]}]},"test:bytestring-tests":{"type":"exitcode-stdio-1.0","main-is":"Main.hs","hs-source-dirs":["tests","tests/builder"],"other-modules":["Builder","Data.ByteString.Builder.Prim.TestUtils","Data.ByteString.Builder.Prim.Tests","Data.ByteString.Builder.Tests","IsValidUtf8","LazyHClose","Lift","Properties","Properties.ByteString","Properties.ByteStringChar8","Properties.ByteStringLazy","Properties.ByteStringLazyChar8","Properties.ShortByteString","QuickCheckUtils"],"default-language":"Haskell2010","ghc-options":["-fwarn-unused-binds","-threaded","-rtsopts"],"build-depends":[{"package":"base","version":">=0","libs":["base"]},{"package":"bytestring","version":">=0","libs":["bytestring"]},{"package":"deepseq","version":">=0","libs":["deepseq"]},{"package":"ghc-prim","version":">=0","libs":["ghc-prim"]},{"package":"QuickCheck","version":">=0","libs":["QuickCheck"]},{"package":"tasty","version":">=0","libs":["tasty"]},{"package":"tasty-quickcheck","version":">=0.8.1","libs":["tasty-quickcheck"]},{"package":"template-haskell","version":">=0","libs":["template-haskell"]},{"package":"transformers","version":">=0.3","libs":["transformers"]},{"package":"syb","version":">=0","libs":["syb"]}]},"bench:bytestring-bench":{"type":"exitcode-stdio-1.0","main-is":"BenchAll.hs","hs-source-dirs":["bench"],"other-modules":["BenchBoundsCheckFusion","BenchCount","BenchCSV","BenchIndices","BenchReadInt","BenchShort"],"default-language":"Haskell2010","ghc-options":["-O2","-with-rtsopts=-A32m",{"_if":{"impl":"ghc","range":">=8.6"},"_then":["-fproc-alignment=64"]}],"build-depends":[{"package":"base","version":">=0","libs":["base"]},{"package":"bytestring","version":">=0","libs":["bytestring"]},{"package":"deepseq","version":">=0","libs":["deepseq"]},{"package":"tasty-bench","version":">=0","libs":["tasty-bench"]},{"package":"random","version":">=0","libs":["random"]}]}}}