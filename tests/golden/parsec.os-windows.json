{"cabal-version":"1.12","name":"parsec","version":"3.1.17.0","license":"BSD2","license-file":["LICENSE"],"license-files":["LICENSE"],"maintainer":"Oleg Grenrus <oleg.grenrus@iki.fi>, Herbert Valerio Riedel <hvr@gnu.org>","author":"Daan Leijen <daan@microsoft.com>, Paolo Martini <paolo@nemail.it>, Antoine Latter <aslatter@gmail.com>","tested-with":[["ghc","==9.10.1 || ==9.8.2 || ==9.6.4 || ==9.4.8 || ==9.2.8 || ==9.0.2 || ==8.10.7 || ==8.8.4 || ==8.6.5 || ==8.4.4 || ==8.2.2 || ==8.0.2 || ==7.10.3 || ==7.8.4 || ==7.6.3 || ==7.4.2"]],"homepage":"https://github.com/haskell/parsec","bug-reports":"https://github.com/haskell/parsec/issues","synopsis":"Monadic parser combinators","description":"Parsec is designed from scratch as an industrial-strength parser\nlibrary.  It is simple, safe, well documented (on the package\nhomepage), has extensive libraries, good error messages,\nand is fast.  It is defined as a monad transformer that can be\nstacked on arbitrary monads, and it is also parametric in the\ninput stream type.\n\nThe main entry point is the \"Text.Parsec\" module which provides\ndefaults for parsing 'Char'acter data.\n\nThe \"Text.ParserCombinators.Parsec\" module hierarchy contains\nthe legacy @parsec-2@ API and may be removed at some point in\nthe future.","category":"Parsing","x-x-revision":"1","build-type":"Simple","extra-source-files":["ChangeLog.md","README.md"],"source-repositories":{"head":{"type":"git","location":"https://github.com/haskell/parsec"}},"components":{"lib":{"exposed-modules":["Text.Parsec","Text.Parsec.String","Text.Parsec.ByteString","Text.Parsec.ByteString.Lazy","Text.Parsec.Text","Text.Parsec.Text.Lazy","Text.Parsec.Pos","Text.Parsec.Error","Text.Parsec.Prim","Text.Parsec.Char","Text.Parsec.Combinator","Text.Parsec.Token","Text.Parsec.Expr","Text.Parsec.Language","Text.Parsec.Perm","Text.ParserCombinators.Parsec","Text.ParserCombinators.Parsec.Char","Text.ParserCombinators.Parsec.Combinator","Text.ParserCombinators.Parsec.Error","Text.ParserCombinators.Parsec.Expr","Text.ParserCombinators.Parsec.Language","Text.ParserCombinators.Parsec.Perm","Text.ParserCombinators.Parsec.Pos","Text.ParserCombinators.Parsec.Prim","Text.ParserCombinators.Parsec.Token"],"hs-source-dirs":["src"],"default-language":"Haskell2010","other-extensions":["CPP","DeriveDataTypeable","ExistentialQuantification","FlexibleContexts","FlexibleInstances","FunctionalDependencies","MultiParamTypeClasses","PolymorphicComponents","StandaloneDeriving","Safe","Trustworthy","UndecidableInstances"],"ghc-options":["-Wall",{"_if":{"impl":"ghc","range":">=8.0"},"_then":["-Wcompat","-Wnoncanonical-monad-instances","-Wno-trustworthy-safe"]},{"_if":{"and":[{"impl":"ghc","range":">=8.0"},{"impl":"ghc","range":"<8.8"}]},"_then":["-Wnoncanonical-monadfail-instances"]},{"_if":{"and":[{"not":{"impl":"ghc","range":">=8.0"}},{"impl":"ghc","range":">=7.10"}]},"_then":["-fno-warn-trustworthy-safe"]}],"build-depends":[{"package":"base","version":">=4.5.1.0 && <4.21","libs":["base"]},{"package":"mtl","version":">=2.1.3.1 && <2.4","libs":["mtl"]},{"package":"bytestring","version":">=0.9.2.1 && <0.13","libs":["bytestring"]},{"package":"text","version":">=1.2.3.0 && <1.3 || >=2.0 && <2.2","libs":["text"]},{"_if":{"not":{"impl":"ghc","range":">=8.0"}},"_then":[{"package":"fail","version":">=4.9 && <4.10","libs":["fail"]},{"package":"semigroups","version":">=0.18 && <0.21","libs":["semigroups"]}]}]},"test:parsec-tests":{"type":"exitcode-stdio-1.0","main-is":"Main.hs","hs-source-dirs":["test"],"other-modules":["Bugs","Bugs.Bug2","Bugs.Bug6","Bugs.Bug9","Bugs.Bug35","Features","Features.Feature80","Features.Feature150","Util"],"default-language":"Haskell2010","ghc-options":["-Wall",{"_if":{"impl":"ghc","range":">=8.0"},"_then":["-Wcompat","-Wnoncanonical-monad-instances","-Wnoncanonical-monadfail-instances"]}],"build-depends":[{"package":"base","version":">=0","libs":["base"]},{"package":"mtl","version":">=0","libs":["mtl"]},{"package":"parsec","version":">=0","libs":["parsec"]},{"package":"tasty","version":">=1.4 && <1.6","libs":["tasty"]},{"package":"tasty-hunit","version":">=0.10 && <0.11","libs":["tasty-hunit"]},{"_if":{"not":{"impl":"ghc","range":">=8.0"}},"_then":[{"package":"semigroups","version":">=0","libs":["semigroups"]}]}]},"test:parsec-issue127":{"type":"exitcode-stdio-1.0","main-is":"issue127.hs","hs-source-dirs":["test"],"default-language":"Haskell2010","build-depends":[{"package":"base","version":">=0","libs":["base"]},{"package":"parsec","version":">=0","libs":["parsec"]}]},"test:parsec-issue171":{"type":"exitcode-stdio-1.0","main-is":"issue171.hs","hs-source-dirs":["test"],"default-language":"Haskell2010","build-depends":[{"package":"base","version":">=0","libs":["base"]},{"package":"tasty","version":">=0","libs":["tasty"]},{"package":"tasty-hunit","version":">=0","libs":["tasty-hunit"]},{"package":"deepseq","version":">=0","libs":["deepseq"]},{"package":"parsec","version":">=0","libs":["parsec"]}]},"test:parsec-issue175":{"type":"exitcode-stdio-1.0","main-is":"issue175.hs","hs-source-dirs":["test"],"default-language":"Haskell2010","build-depends":[{"package":"base","version":">=0","libs":["base"]},{"package":"tasty","version":">=0","libs":["tasty"]},{"package":"tasty-hunit","version":">=0","libs":["tasty-hunit"]},{"package":"parsec","version":">=0","libs":["parsec"]}]}}}